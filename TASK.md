# ТЕХНИЧЕСКОЕ ЗАДАНИЕ: Моделирование выборок частично различимых частиц

## 1. Постановка вычислительной задачи

**Цель:** Разработать программный модуль для вычисления вероятности обнаружения конкретного распределения частиц на выходе линейного многопортового устройства (интерферометра), учитывая степень схожести (различимости) этих частиц.

**Входные данные:**

1. **Матрица рассеяния ():** Унитарная комплексная матрица размера , описывающая интерферометр.
2. **Входное распределение ():** Вектор длины  с целыми числами, где  — количество частиц, поданных во входной порт . Общее число частиц .
3. **Выходное распределение ():** Вектор длины  с целыми числами, где  — количество частиц, зарегистрированных в выходном порту . Условие валидности: .
4. **Матрица различимости ():** Эрмитова положительно определенная матрица размера . Элемент  (число от 0 до 1) характеризует степень «схожести» -й и -й частицы.
* 1 = частицы абсолютно идентичны.
* 0 = частицы абсолютно различимы.



**Выходные данные:**

* **Вероятность ():** Вещественное число , равное вероятности перехода из состояния  в состояние  при заданном  и .

---

## 2. Математические объекты и предобработка данных

Перед вычислением основной формулы необходимо преобразовать физические параметры в рабочие матрицы.

### 2.1. Развертывание списков частиц

Исходные векторы  и  (длины ) показывают *количество* частиц в портах. Для вычислений нужно составить списки индексов портов для каждой частицы (длины ).

* **Входной список индексов ():**
Развернуть вектор . Если , то список портов, откуда пришли частицы:
 (индексация с 0).
Длина списка равна .
* **Выходной список индексов ():**
Аналогично развернуть вектор . Если , то список портов, где детектируются частицы:
.
Длина списка равна .

### 2.2. Формирование эффективной матрицы рассеяния ()

Из большой матрицы  () необходимо сформировать подматрицу  размера , выбрав строки и столбцы согласно спискам  и .

**Правило формирования:**



где .

> **Примечание:** Если во входном/выходном векторе есть числа  (несколько частиц в одном порту), соответствующие строки/столбцы в  будут дублироваться. Это корректно и необходимо.
> 
> 

### 2.3. Матрица различимости ()

Матрица  подается на вход уже в размере .

*  — это скалярное произведение внутренних состояний -й и -й частицы.
* Главная диагональ  всегда содержит .



---

## 3. Основная формула (Тензорный Перманент)

Для вычисления вероятности используется формализм **тензорного перманента**, который объединяет свойства интерферометра и различимости частиц.

### 3.1. Определение 3-тензора 

Необходимо построить трехмерный массив данных (тензор)  размером .
Элементы тензора вычисляются следующим образом:

Где:

*  — индекс «строки» (отвечает за прямую эволюцию).
*  — индекс «строки» (отвечает за сопряженную эволюцию).
*  — индекс «столбца» (выходной канал).
*  — комплексно сопряженный элемент.

### 3.2. Формула вероятности (Алгоритм Райзера)

Вероятность  равна перманенту тензора . Поскольку прямой перебор перестановок  вычислительно сложен, используется обобщенный алгоритм Райзера (принцип включения-исключения).

**Важное дополнение (Нормировка):**
В формуле выше добавлен множитель . Он необходим для компенсации комбинаторных факторов, если на входе или выходе несколько частиц занимают один и тот же порт. Если все , множитель равен 1.

---

## 4. Алгоритм вычисления (Пошагово)

### Шаг 1: Инициализация

1. Получить .
2. Вычислить нормализационный коэффициент: .
3. Сформировать списки  и .
4. Создать матрицу  ().
5. Создать тензор  () согласно п. 3.1.

### Шаг 2: Цикл по подмножествам (Битовые маски)

Сумма в формуле идет по всем подмножествам индексов  и . Это реализуется через две целочисленные маски от  до .

1. Инициализировать аккумулятор `TotalSum = 0` (тип Complex, но в конце мнимая часть должна уйти в 0).
2. **Цикл 1:** `maskA` от  до .
* Определить подмножество : индексы битов, равных 1 в `maskA`.
* Вычислить четность : `signA = (-1)^popcount(maskA)`.


3. **Цикл 2:** `maskB` от  до .
* Определить подмножество : индексы битов, равных 1 в `maskB`.
* Вычислить четность : `signB = (-1)^popcount(maskB)`.
* Вычислить общий знак: `Sign = signA * signB`.



### Шаг 3: Вычисление произведения (Внутреннее тело)

Внутри вложенных циклов нужно вычислить произведение сумм (Product of Sums):

1. Инициализировать `Prod = 1.0`.
2. **Цикл 3:** по  от  до .
* Инициализировать `InnerSum = 0.0`.
* **Суммирование:**



*(Оптимизация: эту сумму можно предварительно вычислить или аккумулировать эффективно)*.
* `Prod *= InnerSum`.


3. `TotalSum += Sign * Prod`.

### Шаг 4: Финализация

1. Результат теоретически вещественный (из-за свойств ), но при вычислениях останется малая мнимая часть.
2. .
3. Вернуть .

---

## 5. Псевдокод (Python-style)

```python
import numpy as np
from itertools import product

def calculate_probability(U, r_vec, s_vec, S_matrix):
    # 1. Expand input/output vectors to index lists
    L_in = []
    for port_idx, count in enumerate(r_vec):
        L_in.extend([port_idx] * count)
    
    L_out = []
    for port_idx, count in enumerate(s_vec):
        L_out.extend([port_idx] * count)
        
    n = len(L_in)
    
    # 2. Build Effective Matrix M (n x n)
    M = np.zeros((n, n), dtype=complex)
    for i in range(n):
        for j in range(n):
            M[i, j] = U[L_in[i], L_out[j]]
            
    # 3. Build Tensor W (n x n x n)
    # W[k, l, j] = M[k, j] * conj(M[l, j]) * S[l, k]
    W = np.zeros((n, n, n), dtype=complex)
    for k in range(n):
        for l in range(n):
            factor = S_matrix[l, k] # S is Hermitian
            for j in range(n):
                W[k, l, j] = M[k, j] * np.conj(M[l, j]) * factor
                
    # 4. Ryser's Algorithm for Tensor Permanent
    total_sum = 0.0 + 0.0j
    
    # Iterate through all subsets A and B (represented by bitmasks)
    # Range is 1 to 2^n because empty set contributions are 0
    # Actually standard Ryser includes 0 but terms sum to 0. 
    # Let's iterate full range.
    
    for mask_A in range(1 << n):
        # Extract indices for set A
        idx_A = [i for i in range(n) if (mask_A & (1 << i))]
        sign_A = -1 if (len(idx_A) % 2 == 1) else 1
        
        for mask_B in range(1 << n):
            idx_B = [i for i in range(n) if (mask_B & (1 << i))]
            sign_B = -1 if (len(idx_B) % 2 == 1) else 1
            
            # Calculate Product term
            prod_term = 1.0 + 0.0j
            
            for j in range(n):
                # Sum W over k in A and l in B for fixed j
                inner_sum = 0.0 + 0.0j
                for k in idx_A:
                    for l in idx_B:
                        inner_sum += W[k, l, j]
                prod_term *= inner_sum
            
            total_sum += (sign_A * sign_B) * prod_term
            
    # 5. Normalization
    normalization = 1.0
    for k in r_vec: normalization *= np.math.factorial(k)
    for k in s_vec: normalization *= np.math.factorial(k)
    
    # Correction factor for generalized Ryser (often (-1)^n)
    # Based on Eq 29/30 logic: pre-factor is (-1)^(n + |R|)
    # Our loops implement (-1)^|A| * (-1)^|B|. 
    # The pure Ryser form for permanent is usually (-1)^n * Sum...
    # For Tensor perm (multidimensional), checking Eq 29 carefully:
    # It requires (-1)^n adjustment if using the standard sum form.
    
    final_prob = total_sum.real * ((-1)**n) / normalization
    
    # Absolute value handles potential global phase issues, 
    # but strictly speaking, P is Re(Sum).
    return max(0.0, final_prob) 

```

---

## 6. Оценка сложности

* **По числу мод ():** Сложность практически не зависит от , так как мы сворачиваем задачу к размерности .
* **По числу частиц ():**
* Внешние циклы (по маскам):  итераций.
* Внутренний цикл (по ):  итераций.
* Внутри цикла по : суммирование .
* **Итоговая асимптотика:** .
* *Для :* мгновенно.
* *Для :*  операций (секунды/минуты).
* *Для :* вычислительно недостижимо.



## 7. Минимальный тестовый пример

Для верификации кода использовать следующие параметры:

**Вход:**

* .
*  (Матрица Адамара/Светоделитель).
*  (по одной частице в каждом входе).
*  (по одной частице в каждом выходе).

**Тест 1: Идентичные бозоны**

* .
* **Ожидаемый результат:**  (Эффект Хонга-Оу-Мандела, полная деструктивная интерференция для исхода [1,1]).

**Тест 2: Различимые частицы**

* .
* **Ожидаемый результат:**  (Классическая вероятность, частицы не интерферируют).

**Тест 3: Частичная различимость**

*  (скалярное произведение ).
* Используя формулу интерполяции из физики (для проверки): .
* **Ожидаемый результат:** .